package cli

import (
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"strings"

	gcli "github.com/urfave/cli"

	"github.com/skycoin/skycoin/src/cipher"
	bip39 "github.com/skycoin/skycoin/src/cipher/go-bip39"
	"github.com/skycoin/skycoin/src/wallet"
)

func addressGenCmd() gcli.Command {
	name := "addressGen"
	return gcli.Command{
		Name:  name,
		Usage: "Generate skycoin or bitcoin addresses",
		Description: `Use caution when using the "-p" command. If you have command history enabled
		your wallet encryption password can be recovered from the history log. If you
		do not include the "-p" option you will be prompted to enter your password
		after you enter your command.`,
		Flags: []gcli.Flag{
			gcli.IntFlag{
				Name:  "num,n",
				Value: 1,
				Usage: "Number of addresses to generate",
			},
			gcli.StringFlag{
				Name:  "coin,c",
				Value: "skycoin",
				Usage: "Coin type. Must be skycoin or bitcoin. If bitcoin, secret keys are in Wallet Import Format instead of hex.",
			},
			gcli.StringFlag{
				Name:  "label,l",
				Value: "",
				Usage: "Wallet label to use when printing or writing a wallet file",
			},
			gcli.BoolFlag{
				Name:  "hex",
				Usage: "Use hex(sha256sum(rand(1024))) (CSPRNG-generated) as the seed if not seed is not provided",
			},
			gcli.StringFlag{
				Name:  "seed,s",
				Usage: "Seed for deterministic key generation. Will use bip39 as the seed if not provided.",
			},
			gcli.IntFlag{
				Name:  "entropy",
				Value: 128,
				Usage: "Entropy of the autogenerated bip39 seed, when the seed is not provided. Can be 128 or 256",
			},
			gcli.BoolFlag{
				Name:  "hide-secrets,hs",
				Usage: "Hide the secret key and seed from the output when printing a JSON wallet file",
			},
			gcli.StringFlag{
				Name:  "mode,m",
				Value: "wallet",
				Usage: `Output mode. Options are wallet (prints a full JSON wallet), addresses (prints addresses in plain text), secrets (prints secret keys in plain text)`,
			},
			gcli.BoolFlag{
				Name:  "encrypt,e",
				Usage: "Encrypt the wallet when printing a JSON wallet",
			},
		},
		OnUsageError: onCommandUsageError(name),
		Action: func(c *gcli.Context) error {
			num := c.Int("num")
			if num <= 0 {
				return errors.New("num must be > 0")
			}

			label := c.String("label")

			coinType, err := wallet.ResolveCoinType(c.String("coin"))
			if err != nil {
				return err
			}

			seed, err := resolveSeed(c)
			if err != nil {
				return err
			}

			mode := c.String("mode")
			encrypt := c.Bool("encrypt")

			var password []byte
			if encrypt {
				switch strings.ToLower(mode) {
				case "json", "wallet":
				default:
					return errors.New("Encrypt flag requires -mode to be json")
				}

				var err error
				password, err = PasswordFromTerm{}.Password()
				if err != nil {
					return err
				}
			}

			w, err := wallet.NewWallet(wallet.NewWalletFilename(), wallet.Options{
				Coin:       coinType,
				Label:      label,
				Seed:       seed,
				Encrypt:    encrypt,
				Password:   password,
				CryptoType: wallet.CryptoTypeScryptChacha20poly1305,
				GenerateN:  uint64(num),
			})
			if err != nil {
				return err
			}

			hideSecrets := c.Bool("hide-secrets")

			if hideSecrets {
				w.Erase()
			}

			rw := wallet.NewReadableWallet(w)

			switch strings.ToLower(mode) {
			case "json", "wallet":
				output, err := json.MarshalIndent(rw, "", "    ")
				if err != nil {
					return err
				}

				fmt.Println(string(output))
			case "addrs", "addresses":
				for _, e := range rw.Entries {
					fmt.Println(e.Address)
				}
			case "secrets":
				if hideSecrets {
					return errors.New("secrets mode selected but hideSecrets enabled")
				}
				for _, e := range rw.Entries {
					fmt.Println(e.Secret)
				}
			default:
				return errors.New("invalid mode")
			}

			return nil
		},
	}
}

func resolveSeed(c *gcli.Context) (string, error) {
	seed := c.String("seed")
	useHex := c.Bool("hex")
	strict := c.Bool("strict-seed")
	entropy := c.Int("entropy")

	switch entropy {
	case 128, 256:
	default:
		return "", errors.New("entropy must be 128 or 256")
	}

	if seed != "" {
		if strict && !bip39.IsMnemonicValid(seed) {
			return "", errors.New("seed is not a valid bip39 seed")
		}

		return seed, nil
	}

	if useHex {
		seed = cipher.SumSHA256(cipher.RandByte(1024)).Hex()
	} else {
		e, err := bip39.NewEntropy(entropy)
		if err != nil {
			return "", err
		}

		seed, err = bip39.NewMnemonic(e)
		if err != nil {
			return "", err
		}
	}

	return seed, nil
}

func fiberAddressGenCmd() gcli.Command {
	name := "fiberAddressGen"
	return gcli.Command{
		Name:  name,
		Usage: "Generate addresses and seeds for a new fiber coin.",
		Description: `Addresses are written in a format that can be copied into fiber.toml
for configuring distribution addresses. Addresses along with their seeds are written to a csv file,
these seeds can be imported into the wallet to access distribution coins.`,
		Flags: []gcli.Flag{
			gcli.IntFlag{
				Name:  "num,n",
				Value: 100,
				Usage: "Number of addresses to generate",
			},
			gcli.IntFlag{
				Name:  "entropy,e",
				Value: 128,
				Usage: "Entropy of the autogenerated bip39 seeds. Can be 128 or 256",
			},
			gcli.StringFlag{
				Name:  "addrs-file,a",
				Value: "addresses.txt",
				Usage: "Output file for the generated addresses in fiber.toml format",
			},
			gcli.StringFlag{
				Name:  "seeds-file,s",
				Value: "seeds.csv",
				Usage: "Output file for the generated addresses and seeds in a csv",
			},
			gcli.BoolFlag{
				Name:  "overwrite,o",
				Usage: "Allow overwriting any existing addrs-file or seeds-file",
			},
		},
		OnUsageError: onCommandUsageError(name),
		Action: func(c *gcli.Context) (err error) {
			if c.NArg() != 0 {
				return errors.New("This command does not take any positional arguments")
			}

			n := c.Int("num")
			if n < 1 {
				return errors.New("num must be > 0")
			}

			entropy := c.Int("entropy")
			switch entropy {
			case 128, 256:
			default:
				return errors.New("entropy must be 128 or 256")
			}

			addrs := make([]cipher.Address, n)
			seeds := make([]string, n)

			for i := 0; i < n; i++ {
				e, err := bip39.NewEntropy(entropy)
				if err != nil {
					return err
				}

				seed, err := bip39.NewMnemonic(e)
				if err != nil {
					return err
				}

				_, seckey, err := cipher.GenerateDeterministicKeyPair([]byte(seed))
				if err != nil {
					return err
				}
				addr := cipher.MustAddressFromSecKey(seckey)

				seeds[i] = seed
				addrs[i] = addr
			}

			overwrite := c.Bool("overwrite")

			addrsFilename := c.String("addrs-file")
			_, err = os.Stat(addrsFilename)
			if err != nil {
				if !os.IsNotExist(err) {
					return err
				}
			} else if !overwrite {
				return fmt.Errorf("-addrs-file %q already exists. Use -overwrite to force writing", addrsFilename)
			}

			seedsFilename := c.String("seeds-file")
			_, err = os.Stat(seedsFilename)
			if err != nil {
				if !os.IsNotExist(err) {
					return err
				}
			} else if !overwrite {
				return fmt.Errorf("-seeds-file %q already exists. Use -overwrite to force writing", seedsFilename)
			}

			addrsF, err := os.Create(addrsFilename)
			if err != nil {
				return err
			}
			defer func() {
				cErr := addrsF.Close()
				if cErr != nil {
					err = cErr
				}
			}()

			seedsF, err := os.Create(seedsFilename)
			defer func() {
				cErr := seedsF.Close()
				if cErr != nil {
					err = cErr
				}
			}()

			for i, a := range addrs {
				if _, err := fmt.Fprintf(addrsF, "\"%s\",\n", a); err != nil {
					return err
				}
				if _, err := fmt.Fprintf(seedsF, "\"%s\",\"%s\"\n", a, seeds[i]); err != nil {
					return err
				}
			}

			return nil
		},
	}
}
